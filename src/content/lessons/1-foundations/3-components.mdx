---
title: Astro Components
description: Learn the two-part anatomy of Astro components -- frontmatter for logic and templates for markup -- and see how familiar React patterns translate to Astro syntax.
chapter: 1
order: 3
difficulty: beginner
objectives:
  - Understand the two-part structure of Astro components
  - Define and use props with TypeScript
  - Use slots instead of children for component composition
  - Write expressions, conditionals, and loops in templates
  - Understand that Astro components run at build time with no client-side runtime
duration: "18 min"
tags:
  - components
  - props
  - slots
  - templates
  - typescript
---

import Callout from '../../../components/Callout.astro';
import ComparisonWidget from '../../../components/interactive/ComparisonWidget.tsx';

## The Two-Part Structure

Every Astro component has two parts, separated by a code fence (`---`):

```astro
---
// Part 1: Component Script (frontmatter)
// Runs at build time in Node.js. Never reaches the browser.
const greeting = "Hello, world!";
---

<!-- Part 2: Component Template -->
<!-- HTML-like markup with expressions. Rendered to static HTML. -->
<h1>{greeting}</h1>
```

The **frontmatter** (between the `---` fences) is where you import modules, fetch data, define variables, and handle all your logic. It runs once at build time (or at request time in SSR mode) and is completely stripped from the output.

The **template** (below the second `---`) is where you write your markup. It looks like JSX but compiles to HTML strings -- no virtual DOM, no diffing algorithm, no runtime overhead.

<Callout type="tip" title="Coming from React?">
  Think of the frontmatter as the body of your React function component (everything before the `return`), and the template as the JSX you return. The critical difference: Astro's frontmatter runs in Node.js at build time, not in the browser. There is no `useState`, no `useEffect`, no re-renders. The component executes once, produces HTML, and is done.
</Callout>

## React vs Astro: Side by Side

Use the interactive comparison below to see how common React patterns translate to Astro. Click through each example to see both versions:

<ComparisonWidget client:idle examples={[
  {
    title: "Basic Component",
    react: `// Greeting.tsx
function Greeting() {
  return (
    <div className="greeting">
      <h1>Hello, world!</h1>
      <p>Welcome to my site.</p>
    </div>
  );
}

export default Greeting;`,
    astro: `<!-- Greeting.astro -->
---
// No imports needed for a simple component.
// No export default — the file IS the component.
---

<div class="greeting">
  <h1>Hello, world!</h1>
  <p>Welcome to my site.</p>
</div>

<style>
  /* Styles are scoped to this component
     automatically. No CSS modules needed. */
  .greeting { padding: 2rem; }
</style>`
  },
  {
    title: "Props",
    react: `// UserCard.tsx
interface UserCardProps {
  name: string;
  role: string;
  avatar?: string;
}

function UserCard({ name, role, avatar }: UserCardProps) {
  return (
    <div className="card">
      {avatar && <img src={avatar} alt={name} />}
      <h2>{name}</h2>
      <span>{role}</span>
    </div>
  );
}

export default UserCard;`,
    astro: `<!-- UserCard.astro -->
---
interface Props {
  name: string;
  role: string;
  avatar?: string;
}

const { name, role, avatar } = Astro.props;
---

<div class="card">
  {avatar && <img src={avatar} alt={name} />}
  <h2>{name}</h2>
  <span>{role}</span>
</div>`
  },
  {
    title: "Conditional Rendering",
    react: `// Alert.tsx
interface AlertProps {
  type: 'success' | 'error' | 'info';
  message: string;
  dismissible?: boolean;
}

function Alert({ type, message, dismissible = false }: AlertProps) {
  const [visible, setVisible] = useState(true);

  if (!visible) return null;

  return (
    <div className={\`alert alert-\${type}\`}>
      <p>{message}</p>
      {dismissible && (
        <button onClick={() => setVisible(false)}>
          Dismiss
        </button>
      )}
    </div>
  );
}`,
    astro: `<!-- Alert.astro -->
---
interface Props {
  type: 'success' | 'error' | 'info';
  message: string;
  dismissible?: boolean;
}

const { type, message, dismissible = false } = Astro.props;
// No useState — this renders once at build time.
// For a dismissible alert, you would use a React
// island or a <script> tag with vanilla JS.
---

<div class={\`alert alert-\${type}\`}>
  <p>{message}</p>
  {dismissible && (
    <button class="dismiss-btn">Dismiss</button>
  )}
</div>

{dismissible && (
  <script>
    // Vanilla JS for simple interactivity.
    // No framework needed for a click handler!
    document.querySelector('.dismiss-btn')
      ?.addEventListener('click', (e) => {
        e.target.closest('.alert').remove();
      });
  </script>
)}`
  },
  {
    title: "List Rendering",
    react: `// PostList.tsx
interface Post {
  id: string;
  title: string;
  date: string;
}

function PostList({ posts }: { posts: Post[] }) {
  return (
    <ul>
      {posts.map(post => (
        <li key={post.id}>
          <a href={\`/posts/\${post.id}\`}>
            {post.title}
          </a>
          <time>{post.date}</time>
        </li>
      ))}
    </ul>
  );
}`,
    astro: `<!-- PostList.astro -->
---
interface Props {
  posts: { id: string; title: string; date: string }[];
}

const { posts } = Astro.props;
---

<ul>
  {posts.map(post => (
    <li>
      {/* No key prop needed — there is no
          virtual DOM to reconcile! */}
      <a href={\`/posts/\${post.id}\`}>
        {post.title}
      </a>
      <time>{post.date}</time>
    </li>
  ))}
</ul>`
  }
]} />

## Props and TypeScript

Astro has first-class TypeScript support. You define your component's props using a `Props` interface in the frontmatter:

```astro
---
interface Props {
  title: string;
  subtitle?: string;
  count: number;
  tags: string[];
  variant: 'primary' | 'secondary';
}

const { title, subtitle, count, tags, variant = 'primary' } = Astro.props;
---

<article class={`card card-${variant}`}>
  <h2>{title}</h2>
  {subtitle && <p class="subtitle">{subtitle}</p>}
  <span>{count} items</span>
  <div class="tags">
    {tags.map(tag => <span class="tag">{tag}</span>)}
  </div>
</article>
```

When you use this component elsewhere, your editor gives you full autocompletion and type checking:

```astro
---
import Card from '../components/Card.astro';
---

<!-- TypeScript catches errors here at build time -->
<Card
  title="My Post"
  count={42}
  tags={["astro", "typescript"]}
  variant="primary"
/>
```

<Callout type="info">
  The `Props` interface name is a convention, not a requirement. Astro will use whatever interface you apply to `Astro.props`. However, naming it `Props` is the standard convention and enables the best editor support.
</Callout>

## Slots: Astro's `children`

In React, you pass nested content using the `children` prop. In Astro, you use `<slot />` -- a web standards concept also used in Web Components and Vue.

```astro
---
// Card.astro
interface Props {
  title: string;
}
const { title } = Astro.props;
---

<div class="card">
  <h3>{title}</h3>
  <div class="card-body">
    <slot />  <!-- Renders whatever is placed between <Card> tags -->
  </div>
</div>
```

Using the component:

```astro
<Card title="Getting Started">
  <p>This paragraph ends up inside the slot.</p>
  <a href="/docs">Read the docs</a>
</Card>
```

### Named Slots

When you need multiple insertion points, Astro supports named slots:

```astro
---
// Layout.astro — a component with multiple slots
---
<div class="page">
  <header>
    <slot name="header" />   <!-- Named slot -->
  </header>
  <main>
    <slot />                  <!-- Default (unnamed) slot -->
  </main>
  <aside>
    <slot name="sidebar" />  <!-- Another named slot -->
  </aside>
</div>
```

```astro
---
// Using named slots
import Layout from './Layout.astro';
---

<Layout>
  <nav slot="header">        <!-- Goes into the "header" slot -->
    <a href="/">Home</a>
  </nav>

  <p>This is the main content.</p>  <!-- Goes into the default slot -->

  <ul slot="sidebar">        <!-- Goes into the "sidebar" slot -->
    <li>Link 1</li>
    <li>Link 2</li>
  </ul>
</Layout>
```

<Callout type="tip" title="Coming from React?">
  Named slots replace the React pattern of passing components as props (e.g., `header={<Nav />}` or `sidebar={<Links />}`). Astro's approach is more declarative -- you annotate the content with `slot="name"` instead of passing it as a prop. If you have used Vue's named slots, this is identical syntax.
</Callout>

### Fallback Content

Slots can have default content that renders when nothing is provided:

```astro
---
// Button.astro
---
<button class="btn">
  <slot>Click me</slot>  <!-- "Click me" is the fallback -->
</button>
```

```astro
<Button />                    <!-- Renders: "Click me" -->
<Button>Submit Form</Button>  <!-- Renders: "Submit Form" -->
```

## Template Expressions

Astro templates support JavaScript expressions inside curly braces, similar to JSX:

```astro
---
const name = "Astro";
const items = ["Components", "Routing", "Layouts"];
const isPublished = true;
const htmlContent = "<strong>Bold text</strong>";
---

<!-- String interpolation -->
<h1>Welcome to {name}</h1>

<!-- Ternary expressions -->
<span class={isPublished ? 'published' : 'draft'}>
  {isPublished ? 'Published' : 'Draft'}
</span>

<!-- Mapping over arrays -->
<ul>
  {items.map(item => <li>{item}</li>)}
</ul>

<!-- Dynamic attributes -->
<div data-count={items.length} class:list={['card', { active: isPublished }]}>
  Content here
</div>

<!-- Rendering raw HTML (be careful with user input!) -->
<div set:html={htmlContent} />
```

<Callout type="warning">
  One key difference from JSX: Astro uses `class` instead of `className`, and standard HTML attribute names instead of camelCase. It is real HTML, not a JavaScript abstraction over HTML. Write `for` instead of `htmlFor`, `class` instead of `className`, and `onclick` instead of `onClick`.
</Callout>

## Top-Level Await: No `useEffect` Needed

One of the most liberating features of Astro components is **top-level `await`** in the frontmatter. Because the frontmatter runs in Node.js at build time, you can use `await` directly without wrapping anything in `useEffect` or managing loading states:

```astro
---
// This runs at build time. No useEffect, no useState, no loading spinner.
const response = await fetch('https://api.github.com/repos/withastro/astro');
const repo = await response.json();

// You can use any Node.js API
import fs from 'node:fs';
const config = JSON.parse(fs.readFileSync('./config.json', 'utf-8'));

// Multiple async operations in sequence
const users = await db.query('SELECT * FROM users WHERE active = true');
const posts = await db.query('SELECT * FROM posts ORDER BY date DESC LIMIT 10');
---

<h1>{repo.full_name}</h1>
<p>Stars: {repo.stargazers_count.toLocaleString()}</p>

<ul>
  {users.map(user => <li>{user.name}</li>)}
</ul>
```

Compare this to the React equivalent, which requires managing three pieces of state (data, loading, error), a `useEffect` hook, cleanup logic, and conditional rendering for each state:

```jsx
function RepoInfo() {
  const [repo, setRepo] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let cancelled = false;
    fetch('https://api.github.com/repos/withastro/astro')
      .then(r => r.json())
      .then(data => { if (!cancelled) { setRepo(data); setLoading(false); } })
      .catch(err => { if (!cancelled) { setError(err); setLoading(false); } });
    return () => { cancelled = true; };
  }, []);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      <h1>{repo.full_name}</h1>
      <p>Stars: {repo.stargazers_count.toLocaleString()}</p>
    </div>
  );
}
```

Fifteen lines of boilerplate versus two lines. And the Astro version has no loading state because the data is already there when the HTML arrives in the browser.

<Callout type="tip" title="Coming from React?">
  If `useEffect` for data fetching is the part of React you like least, you are going to love Astro. Top-level `await` in the frontmatter eliminates an entire category of complexity: loading states, race conditions, stale closures, cleanup functions, and the "waterfall" of sequential renders. The data is fetched once, at build time, and baked into the HTML.
</Callout>

## No Re-Renders, No Lifecycle

This is the concept that takes the longest to internalize coming from React: **Astro components do not re-render.** There is no component lifecycle, no state updates, no reconciliation. The component executes once and produces a string of HTML.

This means:

- **No `useState`** -- there is no state to manage because the component only runs once.
- **No `useEffect`** -- there are no side effects to run after rendering because there is no browser context.
- **No `useRef`** -- there is no DOM to reference because the component runs on the server.
- **No `useMemo` / `useCallback`** -- there is no re-rendering to optimize.
- **No context providers** -- there is no component tree that persists in memory.

If you need any of these features, that is your signal to use a **React island** -- a React component that hydrates in the browser with client-side JavaScript. We cover this in detail in Chapter 4 (Islands Architecture).

```astro
---
// WRONG: This does not work in an Astro component
// import { useState } from 'react';  // ← React hooks cannot be used here
// const [count, setCount] = useState(0);

// RIGHT: For interactivity, use a React component as an island
import Counter from '../components/interactive/Counter.tsx';
---

<!-- Static content (no JS) -->
<h1>My Page</h1>
<p>This is static HTML.</p>

<!-- Interactive island (ships React + JS for this component only) -->
<Counter client:load />
```

## The `class:list` Utility

Astro includes a built-in utility for conditional CSS classes, eliminating the need for libraries like `clsx` or `classnames`:

```astro
---
const { variant = 'default', isActive, size } = Astro.props;
---

<button class:list={[
  'btn',
  `btn-${variant}`,
  { 'btn-active': isActive },
  { 'btn-lg': size === 'large', 'btn-sm': size === 'small' },
]}>
  <slot />
</button>
```

The `class:list` directive accepts an array of strings, objects (where truthy values include the class), and nested arrays. It works exactly like `clsx` but is built into the template language.

## Wrapping Up

Astro components are deceptively simple. They look like JSX, feel familiar to React developers, and compile to zero client-side JavaScript. The two-part structure (frontmatter + template) cleanly separates logic from presentation, and the build-time execution model eliminates entire categories of complexity.

The key takeaways:

1. **Frontmatter runs at build time** in Node.js -- use it for data fetching, imports, and logic.
2. **Templates render to static HTML** -- use expressions, conditionals, and loops just like JSX.
3. **Props use TypeScript** via the `Props` interface and `Astro.props`.
4. **Slots replace children** -- use `<slot />` for default content and named slots for multiple insertion points.
5. **No hooks, no state, no lifecycle** -- if you need interactivity, use a framework island.

Next up: we will see how layouts compose these components into complete pages.
