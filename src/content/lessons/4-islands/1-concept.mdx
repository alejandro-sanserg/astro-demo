---
title: "The Islands Concept"
description: "Understand the islands architecture pattern that makes Astro fundamentally different from React — ship zero JavaScript by default, then add interactivity exactly where you need it."
chapter: 4
order: 1
difficulty: "intermediate"
objectives:
  - "Define islands architecture and explain its origins"
  - "Contrast the islands model with React's full-page hydration approach"
  - "Articulate the performance benefits of shipping less JavaScript"
  - "Apply the mental model of 'static by default, interactive by choice'"
  - "Identify when islands architecture is the right fit vs a full SPA"
duration: "12 min"
tags:
  - "islands"
  - "architecture"
  - "performance"
  - "hydration"
  - "mental-model"
---

import Callout from '../../../components/Callout.astro';

# The Islands Concept

If there is one idea that separates Astro from every framework you have used before, it is **islands architecture**. This is not a feature bolted onto the side of a server-rendered React app. It is the foundational design decision that shapes everything Astro does — how it builds pages, how it ships (or doesn't ship) JavaScript, and how it thinks about interactivity on the web.

Coming from React, you have spent your career in a world where every component is interactive by default. The entire page is a living, breathing React tree. Islands architecture flips that assumption completely: **nothing is interactive by default**. You opt in, per component, when you actually need JavaScript in the browser.

This lesson will change how you think about building for the web.

## The Origin: Jason Miller's Insight

The term "islands architecture" was coined by Preact creator Jason Miller in a 2020 blog post. The core observation was simple but powerful: most of a typical web page is static content. A blog post is text. A product page is images, descriptions, and specs. A documentation site is paragraphs and code blocks. Yet frameworks like React, Next.js, and Gatsby hydrate the *entire page* with JavaScript — even the parts that will never change or respond to user input.

Miller proposed a different model: treat the page as a **static HTML document** (the "ocean") with small, self-contained **interactive components** (the "islands") embedded within it. Each island hydrates independently. The static parts never load a single byte of JavaScript.

Astro is the framework that took this idea and built an entire developer experience around it.

## The Newspaper Analogy

Think about a physical newspaper. When you pick one up, the vast majority of what you see is static: headlines, body text, photographs, advertisements. It is printed ink on paper. It does not need electricity or a computer to work.

Now imagine that newspaper has a few special sections: a QR code that links to a live poll, a small embedded screen showing a live stock ticker, and a scratch-off game. These are the **interactive islands** — small, self-contained widgets that need "power" to function. Everything else is just content.

A traditional React application treats the entire newspaper as if it were a tablet. Every headline, every paragraph, every photo is rendered by a JavaScript runtime, even though none of those elements need interactivity. You are shipping a computer to display ink.

Astro treats it like an actual newspaper: static content is static HTML. Only the poll, the stock ticker, and the scratch-off game get JavaScript. The result is a page that loads faster, uses less bandwidth, and works even if JavaScript fails.

## How React Hydrates: The "Whole Page" Problem

Let's be concrete about what happens in a typical React SSR setup (Next.js, Remix, etc.):

1. The server renders your React component tree to HTML and sends it to the browser.
2. The browser displays this HTML immediately — the page *looks* loaded.
3. The browser downloads the entire React runtime plus your entire component tree as JavaScript.
4. React "hydrates" the page: it walks the DOM, attaches event listeners, and takes over. Now buttons work, forms submit, and state updates flow.

The problem is step 3. Even if your page is a blog post with a single "like" button, the browser downloads JavaScript for the header, the sidebar, the footer, the markdown renderer, the syntax highlighter, and every other component on the page. React needs the full tree to reconcile its virtual DOM.

This is not a criticism of React — it is a consequence of the single-page application model. When your entire page is one React app, you need the entire app's code to hydrate any part of it.

<Callout type="info" title="The Cost of Hydration">
  Hydration is not free. Beyond the download cost, the browser must parse, compile, and execute all that JavaScript, then walk the DOM to attach event listeners. On a mid-range mobile device, this can block the main thread for hundreds of milliseconds — or even seconds on complex pages. This is why "Time to Interactive" (TTI) is often much worse than "First Contentful Paint" (FCP) in SSR React apps.
</Callout>

## How Astro Hydrates: Per-Component Opt-In

Astro takes the opposite approach. Here is what happens when Astro builds a page:

1. At build time (or on the server for SSR), Astro renders your page to **plain HTML**. Components written in Astro, React, Vue, Svelte — it doesn't matter — they all produce static HTML.
2. The browser receives this HTML. **No JavaScript is sent by default.** The page is fully rendered and functional as a static document.
3. For any component where you have explicitly added a `client:*` directive, Astro sends *only that component's* JavaScript. Each island hydrates independently, on its own schedule.

The critical difference: if your page has 50 components and only 2 are interactive, Astro ships JavaScript for exactly 2 components. The other 48 are pure HTML. They never download a framework runtime. They never hydrate. They just *exist*.

```astro
---
// This page has many components but only ONE ships JavaScript
import Header from '../components/Header.astro';
import ArticleBody from '../components/ArticleBody.astro';
import Sidebar from '../components/Sidebar.astro';
import Footer from '../components/Footer.astro';
import LikeButton from '../components/interactive/LikeButton.tsx';
---

<Header />           <!-- Static HTML, 0 KB JavaScript -->
<ArticleBody />      <!-- Static HTML, 0 KB JavaScript -->
<Sidebar />          <!-- Static HTML, 0 KB JavaScript -->
<LikeButton client:load />  <!-- This one gets React + its JS -->
<Footer />           <!-- Static HTML, 0 KB JavaScript -->
```

That `client:load` directive on `LikeButton` is the only thing that triggers JavaScript delivery. Everything else is just HTML and CSS.

## The Mental Model: Start Static, Add Interactivity Surgically

Here is the mental shift that will serve you best as a React developer learning Astro:

**In React, you start with full interactivity and try to optimize away what you don't need** (code splitting, lazy loading, React Server Components). The default is "everything is JavaScript."

**In Astro, you start with zero interactivity and add it exactly where needed.** The default is "everything is HTML."

This means your thought process changes:

| React Thinking | Astro Thinking |
|---|---|
| "How do I optimize this page?" | "Does this component even need JavaScript?" |
| "Let me code-split this route" | "Only 2 of 30 components here need JS" |
| "I'll lazy-load below the fold" | "Below-the-fold components are already zero JS" |
| "Server Components can reduce bundle" | "There is no bundle unless I opt in" |

<Callout type="tip" title="The 90/10 Rule">
  On most content-driven websites, roughly 90% of the page is static content and 10% is interactive. Islands architecture is designed for exactly this ratio. You get the developer experience of using React (or any framework) for your interactive components, without paying the performance cost for the other 90%.
</Callout>

## Performance Benefits: The Numbers

The performance implications of islands architecture are significant and measurable:

**Less JavaScript downloaded.** A typical React SPA might ship 200-500 KB of JavaScript (gzipped) for a content page. An equivalent Astro page with a couple of islands might ship 20-50 KB — only the framework runtime and component code for the interactive parts.

**Faster Time to Interactive.** Because there is less JavaScript to download, parse, and execute, the page becomes interactive sooner. Static parts of the page are interactive *immediately* (links work, forms submit natively) because they are plain HTML.

**No hydration mismatch risk for static content.** One of the trickiest bugs in React SSR is hydration mismatches — when the server-rendered HTML doesn't match what React produces on the client. In Astro, static components never hydrate, so they can never mismatch.

**Better Core Web Vitals.** Less JavaScript means lower Total Blocking Time (TBT), faster Largest Contentful Paint (LCP) because the main thread isn't busy parsing scripts, and better Interaction to Next Paint (INP) because there's less competing for the main thread.

## When Islands Are the Right Choice

Islands architecture shines when your content-to-interactivity ratio is high. Here are strong use cases:

- **Marketing sites** — mostly text, images, and CTAs with a few interactive forms or calculators
- **Documentation sites** — paragraphs of text with interactive code playgrounds or search
- **Blogs and magazines** — articles with comment sections, share buttons, or embedded demos
- **E-commerce product pages** — product descriptions and images with an "add to cart" button and image carousel
- **Dashboards with static structure** — the layout and labels are static; charts and filters are islands

## When a Full SPA Might Be Better

Islands architecture is not the right fit for every application. Consider a full SPA (React, Next.js, Remix) when:

- **Nearly everything is interactive** — apps like Figma, Google Docs, or Spotify where the entire UI responds to user input constantly
- **Complex client-side state flows** — when components need to share state extensively and in real time (drag-and-drop builders, real-time collaboration)
- **Single-page navigation is critical** — apps where transitions between views must be instant and preserve complex client state (a multi-step form wizard with animations)

<Callout type="warning" title="Honest Assessment">
  If you are building a highly interactive dashboard where 80%+ of the page needs JavaScript, Astro's islands model adds friction. You would spend more time adding `client:*` directives than you would save. For these use cases, a React framework like Next.js or Remix is a better fit. The power of islands comes from the asymmetry — a lot of static content with targeted interactivity.
</Callout>

## What's Coming Next

Now that you understand the *concept* of islands, the next two lessons will make it concrete. In the next lesson, you will integrate React into an Astro project and see firsthand what happens when you render a React component with and without a client directive. In the final lesson of this chapter, you will explore every client directive Astro offers and learn exactly when to use each one.

The key takeaway from this lesson: **Astro doesn't fight the web. It embraces the fact that most of what we build is content — and content doesn't need a JavaScript runtime.** When something *does* need interactivity, you add it precisely where it's needed, and not a byte more.

This is islands architecture. And once it clicks, you will never look at a web page the same way again.
